{"version":3,"sources":["containers/weather/WeatherContainer.js"],"names":["WeatherContainer","addressContext","useContext","AddressContext","useState","weatherForecast","setWeatherForecast","weatherCurrent","setWeatherCurrent","isLoading","setIsLoading","validCityName","isEmpty","address","isUndefined","cityName","fetchWeatherData","a","async","FetchWeatherData","then","response","current","forecast","catch","err","Sentry","finally","useEffect","timer","setInterval","clearInterval","loaderText","className","errorMessage","latlong","urbanArea"],"mappings":"4OAgHeA,UAvGU,WACvB,IAAMC,EAAiBC,qBAAWC,KADL,EAGiBC,mBAAS,IAH1B,mBAGtBC,EAHsB,KAGLC,EAHK,OAIeF,mBAAS,IAJxB,mBAItBG,EAJsB,KAINC,EAJM,OAKKJ,oBAAS,GALd,mBAKtBK,EALsB,KAKXC,EALW,KAQvBC,EAAgB,WACpB,IACGC,YAAQX,EAAeY,WACvBC,YAAYb,EAAeY,SAC5B,CACA,IAAME,EAAWd,EAAeY,QAAQE,SACxC,OACGH,YAAQG,KACRD,YAAYC,IACA,oCAAbA,EAGJ,OAAO,GAUHC,EAAmB,oBAAAC,EAAAC,OAAA,uDACvBR,GAAa,GADU,WAAAO,EAAA,MAEjBE,YAAiBlB,GACpBmB,MAAK,SAAAC,GAAa,IAVCC,EAASC,EAWpBhB,EAAmCc,EAAnCd,eAAgBF,EAAmBgB,EAAnBhB,gBAXLiB,EAcHf,EAdYgB,EAcIlB,EAb9BO,YAAQU,IAAaV,YAAQW,KAChCf,EAAkBc,GAClBhB,EAAmBiB,OAalBC,OAAM,SAAAC,GACLC,IAAwBD,MAEzBE,SAAQ,WACPjB,GAAa,OAbM,sCA6BzB,OAZAkB,qBAAU,WACRZ,IACA,IAAMa,EAAQC,aAAY,WACxBd,MACC,MAEH,OAAO,WACLe,cAAcF,MAGf,CAAC5B,IAGF,kBAAC,WAAD,KACIa,YAAYP,IAAoBK,YAAQL,GASxC,kBAAC,WAAD,KACGE,EACC,kBAAC,IAAD,CACEuB,WAAU,oCACRrB,IAAa,cAAYV,EAAeY,QAAQE,UAAa,GADrD,mBAKZ,6BACGJ,IAIC,yBAAKsB,UAAU,uBACb,yBAAKA,UAAU,+BACb,kBAAC,IAAD,CACEC,aAAY,iEACVvB,IAAa,cACFV,EAAeY,QAAQE,UAC9B,GAHM,sBAQhB,OAhCV,kBAAC,IAAD,CACER,eAAgBA,EAChBF,gBAAiBA,EACjBQ,QAASZ,EAAeY,QACxBsB,QAASlC,EAAekC,QACxBC,UAAWnC,EAAemC","file":"static/js/9.ccbac2a1.chunk.js","sourcesContent":["import React, {useState, useEffect, useContext, Fragment} from 'react'\r\nimport {AddressContext} from '../../context/AddressContext'\r\nimport FetchWeatherData from '../../utils/FetchWeatherData'\r\nimport {isUndefined, isEmpty} from 'lodash-es'\r\nimport WeatherForecastContainer from '../weather-forecast/WeatherForecastContainer'\r\nimport LoaderComponent from '../../components/loader/LoaderComponent'\r\nimport ErrorComponent from '../../components/error/ErrorComponent'\r\nimport * as Sentry from '@sentry/browser'\r\n\r\nconst WeatherContainer = () => {\r\n  const addressContext = useContext(AddressContext)\r\n\r\n  const [weatherForecast, setWeatherForecast] = useState({})\r\n  const [weatherCurrent, setWeatherCurrent] = useState({})\r\n  const [isLoading, setIsLoading] = useState(true)\r\n\r\n  // check whether the cityName is valid\r\n  const validCityName = () => {\r\n    if (\r\n      !isEmpty(addressContext.address) &&\r\n      !isUndefined(addressContext.address)\r\n    ) {\r\n      const cityName = addressContext.address.cityName\r\n      return (\r\n        !isEmpty(cityName) &&\r\n        !isUndefined(cityName) &&\r\n        cityName !== 'undefined, undefined, undefined'\r\n      )\r\n    }\r\n    return false\r\n  }\r\n\r\n  const setWeatherData = (current, forecast) => {\r\n    if (!isEmpty(current) && !isEmpty(forecast)) {\r\n      setWeatherCurrent(current)\r\n      setWeatherForecast(forecast)\r\n    }\r\n  }\r\n\r\n  const fetchWeatherData = async () => {\r\n    setIsLoading(true)\r\n    await FetchWeatherData(addressContext)\r\n      .then(response => {\r\n        const {weatherCurrent, weatherForecast} = response\r\n        // set the weatherCurrent and weatherForecast only when the data is non-empty\r\n        // this way, the old fetched data can be preserved when api call fail or limit exceed\r\n        setWeatherData(weatherCurrent, weatherForecast)\r\n      })\r\n      .catch(err => {\r\n        Sentry.captureException(err)\r\n      })\r\n      .finally(() => {\r\n        setIsLoading(false)\r\n      })\r\n  }\r\n\r\n  useEffect(() => {\r\n    fetchWeatherData()\r\n    const timer = setInterval(() => {\r\n      fetchWeatherData()\r\n    }, 3600000)\r\n\r\n    return () => {\r\n      clearInterval(timer)\r\n    }\r\n    // eslint-disable-next-line\r\n  }, [addressContext])\r\n\r\n  return (\r\n    <Fragment>\r\n      {!isUndefined(weatherCurrent) && !isEmpty(weatherCurrent) ? (\r\n        <WeatherForecastContainer\r\n          weatherCurrent={weatherCurrent}\r\n          weatherForecast={weatherForecast}\r\n          address={addressContext.address}\r\n          latlong={addressContext.latlong}\r\n          urbanArea={addressContext.urbanArea}\r\n        />\r\n      ) : (\r\n        <Fragment>\r\n          {isLoading ? (\r\n            <LoaderComponent\r\n              loaderText={`Fetching weather forecast ${\r\n                validCityName() ? `for ${addressContext.address.cityName}` : ''\r\n              } ðŸ˜Ž`}\r\n            />\r\n          ) : (\r\n            <div>\r\n              {validCityName() ? (\r\n                // show error component only when addressContext cityName is valid\r\n                // since by default on component load, addressContext address is empty\r\n                // this extra check will hide error and show only when api call fetch fail for fetching weatherData\r\n                <div className='flex justify-center'>\r\n                  <div className='sm:w-full lg:w-2/3 xl:w-1/2'>\r\n                    <ErrorComponent\r\n                      errorMessage={`Something went wrong. Failed to fetch weather forecast ${\r\n                        validCityName()\r\n                          ? `for ${addressContext.address.cityName}`\r\n                          : ''\r\n                      }! ðŸ˜¢`}\r\n                    />\r\n                  </div>\r\n                </div>\r\n              ) : null}\r\n            </div>\r\n          )}\r\n        </Fragment>\r\n      )}\r\n    </Fragment>\r\n  )\r\n}\r\n\r\nexport default WeatherContainer\r\n"],"sourceRoot":""}